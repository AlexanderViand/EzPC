// Author: AI Assistant / Claude
// Generated by Claude for GPU-MPC optimizations
// Copyright:
// 
// Copyright (c) 2024 Microsoft Research
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

/*
 * SECURE AUTHENTICATED COMMUNICATION
 * ==================================
 * 
 * This file provides authenticated communication wrapper for GPU-MPC.
 * 
 * SECURITY MODEL:
 * - All messages are authenticated using HMAC-SHA256
 * - Sequence numbers prevent replay attacks
 * - Random nonces prevent identical message attacks
 * - Constant-time HMAC verification prevents timing attacks
 * - Memory is securely cleared after use
 * 
 * KEY MANAGEMENT WARNING:
 * The current implementation uses locally generated random keys which
 * means each party will have different keys. For production use:
 * 
 * Option 1 (Recommended): Use pre-shared keys
 *   SecureGpuPeer peer(preshared_key, 32);
 * 
 * Option 2: Implement proper key exchange
 *   Replace performKeyExchange() with Diffie-Hellman or similar
 * 
 * Option 3: Use out-of-band key distribution
 *   Distribute keys through secure channel, then use setPreSharedKey()
 */

#include "gpu_comms.cuh"
#include "secure_error.h"
#include "secure_mem.h"
#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <string>
#include <array>
#include <chrono>

// Constants for authenticated communication
#define HMAC_KEY_SIZE 32        // 256-bit HMAC key
#define HMAC_TAG_SIZE 32        // 256-bit HMAC tag (SHA-256)
#define NONCE_SIZE 16           // 128-bit nonce
#define MAX_MESSAGE_SIZE (1024 * 1024 * 1024)  // 1GB max message size

// Authenticated message structure
struct AuthenticatedMessage {
    uint32_t sequence_number;
    uint32_t message_length;
    uint8_t nonce[NONCE_SIZE];
    uint8_t hmac_tag[HMAC_TAG_SIZE];
    // Variable length payload follows
};

// Secure authenticated communication wrapper extending GpuPeer
class SecureGpuPeer : public GpuPeer {
private:
    std::array<uint8_t, HMAC_KEY_SIZE> hmac_key;
    uint32_t send_sequence;
    uint32_t expected_recv_sequence;
    bool authenticated_connection;
    bool key_established;
    
    // Generate cryptographically secure random bytes
    bool generateSecureRandom(uint8_t* buffer, size_t size) {
        if (RAND_bytes(buffer, size) != 1) {
            secureLogError("SecureGpuPeer::generateSecureRandom", -1);
            return false;
        }
        return true;
    }
    
    // Compute HMAC-SHA256
    bool computeHMAC(const uint8_t* key, size_t key_len,
                     const uint8_t* data, size_t data_len,
                     uint8_t* hmac_out) {
        unsigned int hmac_len;
        if (HMAC(EVP_sha256(), key, key_len, data, data_len, hmac_out, &hmac_len) == nullptr) {
            secureLogError("SecureGpuPeer::computeHMAC", -1);
            return false;
        }
        return (hmac_len == HMAC_TAG_SIZE);
    }
    
    // Verify HMAC-SHA256
    bool verifyHMAC(const uint8_t* key, size_t key_len,
                    const uint8_t* data, size_t data_len,
                    const uint8_t* expected_hmac) {
        uint8_t computed_hmac[HMAC_TAG_SIZE];
        if (!computeHMAC(key, key_len, data, data_len, computed_hmac)) {
            return false;
        }
        
        // Use constant-time comparison to prevent timing attacks
        return CRYPTO_memcmp(computed_hmac, expected_hmac, HMAC_TAG_SIZE) == 0;
    }
    
    // Secure key exchange (simplified - in production use proper key exchange)
    // WARNING: This implementation generates random keys locally and does NOT
    // perform actual key exchange between parties. In production, this should
    // implement proper key exchange protocols like Diffie-Hellman or use
    // pre-shared keys distributed through a secure out-of-band channel.
    bool performKeyExchange() {
        // Generate random HMAC key locally (NOT secure for production)
        if (!generateSecureRandom(hmac_key.data(), HMAC_KEY_SIZE)) {
            return false;
        }
        
        // Log warning about insecure key generation
        secureLogError("SecureGpuPeer::performKeyExchange::WARNING: Using locally generated keys - parties will have different keys", 0);
        
        // Reset sequence numbers
        send_sequence = 0;
        expected_recv_sequence = 0;
        
        key_established = true;
        return true;
    }
    
public:
    // Default constructor - requires key exchange or pre-shared key setup
    SecureGpuPeer(bool compress = false) : GpuPeer(compress), 
                                          send_sequence(0), 
                                          expected_recv_sequence(0),
                                          authenticated_connection(false),
                                          key_established(false) {
        // Initialize OpenSSL
        OpenSSL_add_all_algorithms();
        
        // Zero out the HMAC key initially
        hmac_key.fill(0);
    }
    
    // Constructor with pre-shared HMAC key (recommended for production)
    SecureGpuPeer(const uint8_t* psk, size_t psk_len, bool compress = false) 
        : GpuPeer(compress), 
          send_sequence(0), 
          expected_recv_sequence(0),
          authenticated_connection(false),
          key_established(false) {
        // Initialize OpenSSL
        OpenSSL_add_all_algorithms();
        
        // Set pre-shared key
        if (psk_len == HMAC_KEY_SIZE && psk != nullptr) {
            memcpy(hmac_key.data(), psk, HMAC_KEY_SIZE);
            key_established = true;
        } else {
            hmac_key.fill(0);
            secureLogError("SecureGpuPeer::constructor::invalidPreSharedKey", psk_len);
        }
    }
    
    ~SecureGpuPeer() {
        // Securely clear the HMAC key
        OPENSSL_cleanse(hmac_key.data(), HMAC_KEY_SIZE);
        
        // Cleanup OpenSSL
        EVP_cleanup();
    }
    
    // Establish secure authenticated connection
    bool connectSecure(int party, std::string addr, int port = 42003) {
        // First establish regular connection
        this->connect(party, addr, port);
        
        // Perform key exchange
        if (!performKeyExchange()) {
            secureLogError("SecureGpuPeer::connectSecure::keyExchange", -1);
            return false;
        }
        
        authenticated_connection = true;
        return true;
    }
    
    // Set pre-shared key (alternative to key exchange)
    bool setPreSharedKey(const uint8_t* psk, size_t psk_len) {
        if (psk_len != HMAC_KEY_SIZE) {
            secureLogError("SecureGpuPeer::setPreSharedKey::invalidKeySize", psk_len);
            return false;
        }
        
        memcpy(hmac_key.data(), psk, HMAC_KEY_SIZE);
        key_established = true;
        
        // Reset sequence numbers
        send_sequence = 0;
        expected_recv_sequence = 0;
        
        return true;
    }
    
    // Authenticated send function
    template <typename T>
    bool sendAuthenticated(T *d_data, int bw, int N, Stats *s) {
        if (!authenticated_connection || !key_established) {
            secureLogError("SecureGpuPeer::sendAuthenticated::notAuthenticated", -1);
            return false;
        }
        
        // Compress and move data to CPU using existing functionality
        size_t memSz = 0, numInts = 0;
        auto d_compressed = this->compressMem(bw, bw, N, d_data, memSz, numInts, s);
        
        // Use secure CPU memory for the message buffer
        SecureCpuMemory<uint8_t> message_buffer(false); // Don't pin, we'll handle this manually
        size_t total_size = sizeof(AuthenticatedMessage) + memSz;
        
        if (!message_buffer.allocate(total_size)) {
            if (d_compressed != (uint8_t*)d_data) {
                gpuFreeSecure(d_compressed, memSz);
            }
            return false;
        }
        
        // Create authenticated message
        AuthenticatedMessage* auth_msg = (AuthenticatedMessage*)message_buffer.getMutable();
        auth_msg->sequence_number = send_sequence++;
        auth_msg->message_length = memSz;
        
        // Generate random nonce
        if (!generateSecureRandom(auth_msg->nonce, NONCE_SIZE)) {
            if (d_compressed != (uint8_t*)d_data) {
                gpuFreeSecure(d_compressed, memSz);
            }
            return false;
        }
        
        // Copy data payload
        moveIntoCPUMemSecure(message_buffer.getMutable() + sizeof(AuthenticatedMessage), 
                            d_compressed, memSz, s);
        
        // Compute HMAC over header + payload (excluding HMAC field itself)
        size_t hmac_data_size = sizeof(AuthenticatedMessage) - HMAC_TAG_SIZE + memSz;
        if (!computeHMAC(hmac_key.data(), HMAC_KEY_SIZE,
                        message_buffer.get(), hmac_data_size,
                        auth_msg->hmac_tag)) {
            if (d_compressed != (uint8_t*)d_data) {
                gpuFreeSecure(d_compressed, memSz);
            }
            return false;
        }
        
        // Send the authenticated message
        auto start = std::chrono::high_resolution_clock::now();
        this->sendBytes(message_buffer.get(), total_size);
        auto end = std::chrono::high_resolution_clock::now();
        auto elapsed = end - start;
        if (s) {
            s->comm_time += std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count();
        }
        
        // Clean up compressed data if it was allocated
        if (d_compressed != (uint8_t*)d_data) {
            gpuFreeSecure(d_compressed, memSz);
        }
        
        return true;
    }
    
    // Authenticated receive function
    template <typename T>
    T* recvAuthenticated(int bw, int N, Stats *s) {
        if (!authenticated_connection || !key_established) {
            secureLogError("SecureGpuPeer::recvAuthenticated::notAuthenticated", -1);
            return nullptr;
        }
        
        // First receive the header to know the payload size
        AuthenticatedMessage header;
        auto start = std::chrono::high_resolution_clock::now();
        this->recvBytes((uint8_t*)&header, sizeof(AuthenticatedMessage));
        
        // Validate message length
        if (header.message_length > MAX_MESSAGE_SIZE) {
            secureLogError("SecureGpuPeer::recvAuthenticated::messageTooLarge", header.message_length);
            return nullptr;
        }
        
        // Allocate secure buffer for full message
        SecureCpuMemory<uint8_t> message_buffer(false);
        size_t total_size = sizeof(AuthenticatedMessage) + header.message_length;
        
        if (!message_buffer.allocate(total_size)) {
            return nullptr;
        }
        
        // Copy header and receive payload
        memcpy(message_buffer.getMutable(), &header, sizeof(AuthenticatedMessage));
        this->recvBytes(message_buffer.getMutable() + sizeof(AuthenticatedMessage), 
                       header.message_length);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto elapsed = end - start;
        if (s) {
            s->comm_time += std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count();
        }
        
        // Verify HMAC
        AuthenticatedMessage* auth_msg = (AuthenticatedMessage*)message_buffer.get();
        uint8_t received_hmac[HMAC_TAG_SIZE];
        memcpy(received_hmac, auth_msg->hmac_tag, HMAC_TAG_SIZE);
        memset(auth_msg->hmac_tag, 0, HMAC_TAG_SIZE); // Zero out for verification
        
        size_t hmac_data_size = sizeof(AuthenticatedMessage) - HMAC_TAG_SIZE + header.message_length;
        if (!verifyHMAC(hmac_key.data(), HMAC_KEY_SIZE,
                       message_buffer.get(), hmac_data_size,
                       received_hmac)) {
            secureLogError("SecureGpuPeer::recvAuthenticated::hmacVerificationFailed", -1);
            return nullptr;
        }
        
        // Verify sequence number
        if (auth_msg->sequence_number != expected_recv_sequence) {
            secureLogError("SecureGpuPeer::recvAuthenticated::sequenceError", 
                          auth_msg->sequence_number);
            return nullptr;
        }
        expected_recv_sequence++;
        
        // Expand and return the data using existing functionality
        uint8_t* payload = message_buffer.getMutable() + sizeof(AuthenticatedMessage);
        size_t memSz = header.message_length;
        size_t numInts = 0;
        this->getMemSz<T>(bw, N, memSz, numInts); // This should match the memSz
        
        auto d_result = this->expandMem<T>(bw, N, payload, memSz, numInts, s);
        return d_result;
    }
    
    // Authenticated versions of the public interface methods
    void SendAuthenticated(u64 *d_data, int bw, u64 N, Stats *s) {
        sendAuthenticated<u64>(d_data, bw, N, s);
    }
    
    void SendAuthenticated(u32 *d_data, int bw, u64 N, Stats *s) {
        sendAuthenticated<u32>(d_data, bw, N, s);
    }
    
    void SendAuthenticated(u8 *d_data, int bw, u64 N, Stats *s) {
        sendAuthenticated<u8>(d_data, bw, N, s);
    }
    
    u8 *RecvAuthenticated(int bw, u64 N, Stats *s) {
        return recvAuthenticated<u8>(bw, N, s);
    }
    
    // Check if connection is authenticated
    bool isAuthenticated() const {
        return authenticated_connection && key_established;
    }
    
    // Get connection statistics
    uint32_t getSendSequence() const { return send_sequence; }
    uint32_t getRecvSequence() const { return expected_recv_sequence; }
};